{
"version":3,
"file":"module$node_modules$refractor$lang$puppet.js",
"lineCount":6,
"mappings":"AAAAA,cAAA,0CAAA,CAA8D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAM3HC,QAASA,OAAM,CAACC,KAAD,CAAQ,CAsIlBA,KApIDC,UAAAF,OAAA,CAAyB,CACvBG,QAAS,CAEP,CACEC,QAAS,sGADX,CAEEC,WAAY,CAAA,CAFd,CAGEC,MAAO,QAHT,CAIEC,OAAQ,CAENC,YAAa,mBAFP,CAJV,CAFO,CAWP,CACEJ,QAAS,oGADX,CAEEC,WAAY,CAAA,CAFd,CAGEI,OAAQ,CAAA,CAHV,CAIEH,MAAO,QAJT;AAKEC,OAAQ,CAENC,YAAa,mBAFP,CALV,CAXO,CAqBP,CACEJ,QAAS,6CADX,CAEEE,MAAO,QAFT,CAGEC,OAAQ,CACNC,YAAa,CACXJ,QAAS,eADE,CAEXC,WAAY,CAAA,CAFD,CADP,CAHV,CArBO,CADc,CAiCvB,oBAAqB,CACnBD,QAAS,2BADU,CAEnBC,WAAY,CAAA,CAFO,CAGnBI,OAAQ,CAAA,CAHW,CAInBH,MAAO,SAJY,CAjCE,CAuCvBI,MAAO,CAELN,QAAS,sFAFJ,CAGLC,WAAY,CAAA,CAHP,CAILI,OAAQ,CAAA,CAJH,CAKLF,OAAQ,CAEN,iBAAkB,CAChBH,QAAS,wCADO,CAEhBG,OAAQ,CACNI,QAAS,KADH,CAFQ,CAFZ,CALH,CAvCgB,CAsDvBA,QAAS,CACPP,QAAS,cADF;AAEPC,WAAY,CAAA,CAFL,CAGPI,OAAQ,CAAA,CAHD,CAtDc,CA2DvBG,OAAQ,CAENR,QAAS,uFAFH,CAGNK,OAAQ,CAAA,CAHF,CAINF,OAAQ,CACN,gBAAiB,CACfH,QAAS,aADM,CAEfG,OAAQ,EAFO,CADX,CAJF,CA3De,CAwEvBM,SAAU,CACRT,QAAS,wBADD,CAERG,OAAQ,CACNC,YAAa,IADP,CAFA,CAxEa,CA8EvB,YAAa,qBA9EU,CA+EvBM,SAAU,CACR,CACEV,QAAS,eADX,CAEEC,WAAY,CAAA,CAFd,CADQ,CAKR,kGALQ,CA/Ea,CAsFvBU,OAAQ,8CAtFe;AAuFvBC,QAAS,oBAvFc,CAyFvBC,QAAS,4IAzFc,CA0FvBC,SAAU,CACRd,QAAS,+MADD,CAERE,MAAO,QAFC,CA1Fa,CA8FvBa,SAAU,kFA9Fa;AA+FvBX,YAAa,kBA/FU,CAiGzB,KAAIY,cAAgB,CAClB,CAEEhB,QAAS,yEAFX,CAGEC,WAAY,CAAA,CAHd,CAIEE,OAAQ,CACN,iBAAkB,CAEhBH,QAAS,sCAFO,CAGhBC,WAAY,CAAA,CAHI,CAIhBC,MAAO,UAJS,CAKhBC,OAAQ,CACNC,YAAa,IADP,CALQ,CADZ,CAUNa,UAAW,CACTjB,QAAS,KADA,CAETE,MAAO,UAFE,CAVL,CAcNgB,KAgBLrB,KAhBWC,UAAAF,OAdA,CAJV,CADkB,CAsBlB,CACEI,QAAS,iCADX,CAEEC,WAAY,CAAA,CAFd,CAGEC,MAAO,UAHT,CAIEC,OAAQ,CACNC,YAAa,IADP,CAJV,CAtBkB,CAmCnBP,MAJDC,UAAAF,OAAA,QAAA,CAAkC,CAAlC,CAAAO,OAAAa,cAAA;AAA4DA,aAI3DnB,MAHDC,UAAAF,OAAA,OAAAO,OAAA,CACE,eADF,CAAAA,OAAAa,cAAA,CAEyBA,aArIN,CAHvBvB,MAAAC,QAAA,CAAiBE,MACjBA,OAAAuB,YAAA,CAAqB,QACrBvB,OAAAwB,QAAA,CAAiB,EAL0G;",
"sources":["node_modules/refractor/lang/puppet.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$refractor$lang$puppet\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict'\n\nmodule.exports = puppet\npuppet.displayName = 'puppet'\npuppet.aliases = []\nfunction puppet(Prism) {\n  ;(function(Prism) {\n    Prism.languages.puppet = {\n      heredoc: [\n        // Matches the content of a quoted heredoc string (subject to interpolation)\n        {\n          pattern: /(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n          lookbehind: true,\n          alias: 'string',\n          inside: {\n            // Matches the end tag\n            punctuation: /(?=\\S).*\\S(?= *$)/ // See interpolation below\n          }\n        }, // Matches the content of an unquoted heredoc string (no interpolation)\n        {\n          pattern: /(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n          lookbehind: true,\n          greedy: true,\n          alias: 'string',\n          inside: {\n            // Matches the end tag\n            punctuation: /(?=\\S).*\\S(?= *$)/\n          }\n        }, // Matches the start tag of heredoc strings\n        {\n          pattern: /@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n          alias: 'string',\n          inside: {\n            punctuation: {\n              pattern: /(\\().+?(?=\\))/,\n              lookbehind: true\n            }\n          }\n        }\n      ],\n      'multiline-comment': {\n        pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n        lookbehind: true,\n        greedy: true,\n        alias: 'comment'\n      },\n      regex: {\n        // Must be prefixed with the keyword \"node\" or a non-word char\n        pattern: /((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          // Extended regexes must have the x flag. They can contain single-line comments.\n          'extended-regex': {\n            pattern: /^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,\n            inside: {\n              comment: /#.*/\n            }\n          }\n        }\n      },\n      comment: {\n        pattern: /(^|[^\\\\])#.*/,\n        lookbehind: true,\n        greedy: true\n      },\n      string: {\n        // Allow for one nested level of double quotes inside interpolation\n        pattern: /([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n        greedy: true,\n        inside: {\n          'double-quoted': {\n            pattern: /^\"[\\s\\S]*\"$/,\n            inside: {\n              // See interpolation below\n            }\n          }\n        }\n      },\n      variable: {\n        pattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n        inside: {\n          punctuation: /::/\n        }\n      },\n      'attr-name': /(?:\\w+|\\*)(?=\\s*=>)/,\n      function: [\n        {\n          pattern: /(\\.)(?!\\d)\\w+/,\n          lookbehind: true\n        },\n        /\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/\n      ],\n      number: /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n      boolean: /\\b(?:true|false)\\b/,\n      // Includes words reserved for future use\n      keyword: /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n      datatype: {\n        pattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n        alias: 'symbol'\n      },\n      operator: /=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\n      punctuation: /[\\[\\]{}().,;]|:+/\n    }\n    var interpolation = [\n      {\n        // Allow for one nested level of braces inside interpolation\n        pattern: /(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,\n        lookbehind: true,\n        inside: {\n          'short-variable': {\n            // Negative look-ahead prevent wrong highlighting of functions\n            pattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n            lookbehind: true,\n            alias: 'variable',\n            inside: {\n              punctuation: /::/\n            }\n          },\n          delimiter: {\n            pattern: /^\\$/,\n            alias: 'variable'\n          },\n          rest: Prism.languages.puppet\n        }\n      },\n      {\n        pattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n        lookbehind: true,\n        alias: 'variable',\n        inside: {\n          punctuation: /::/\n        }\n      }\n    ]\n    Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation\n    Prism.languages.puppet['string'].inside[\n      'double-quoted'\n    ].inside.interpolation = interpolation\n  })(Prism)\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","puppet","Prism","languages","heredoc","pattern","lookbehind","alias","inside","punctuation","greedy","regex","comment","string","variable","function","number","boolean","keyword","datatype","operator","interpolation","delimiter","rest","displayName","aliases"]
}
