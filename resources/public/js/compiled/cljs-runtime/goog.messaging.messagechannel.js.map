{
"version":3,
"file":"goog.messaging.messagechannel.js",
"lineCount":32,
"mappings":"AAiCAA,IAAAC,QAAA,CAAa,+BAAb,CAAA;AAOA,kBAAAD,IAAAE,UAAAC,eAAA,GAAgCC,QAAQ,EAAG;CAA3C;AAeA;;;AAAAJ,IAAAE,UAAAC,eAAAE,UAAAC,QAAA,GAAkDC,QAAQ,CAACC,aAAD,CAAgB;CAA1E;AAYA;;;AAAAR,IAAAE,UAAAC,eAAAE,UAAAI,YAAA,GAAsDC,QAAQ,EAAG;CAAjE;AAoBA;;;;;AAAAV,IAAAE,UAAAC,eAAAE,UAAAM,gBAAA,GAA0DC,QAAQ,CAC9DC,WAD8D,EACjDC,QADiD,EACvCC,iBADuC,CACpB;CAD9C;AAaA;;;AAAAf,IAAAE,UAAAC,eAAAE,UAAAW,uBAAA,GAAiEC,QAAQ,CACrEH,QADqE,CAC3D;CADd;AAcA;;;;AAAAd,IAAAE,UAAAC,eAAAE,UAAAa,KAAA,GAA+CC,QAAQ,CAACN,WAAD,EAAcO,OAAd,CAAuB;CAA9E;;",
"sources":["goog/messaging/messagechannel.js"],
"sourcesContent":["// Copyright 2010 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview An interface for asynchronous message-passing channels.\n *\n * This interface is useful for writing code in a message-passing style that's\n * independent of the underlying communication medium. It's also useful for\n * adding decorators that wrap message channels and add extra functionality on\n * top. For example, {@link goog.messaging.BufferedChannel} enqueues messages\n * until communication is established, while {@link goog.messaging.MultiChannel}\n * splits a single underlying channel into multiple virtual ones.\n *\n * Decorators should be passed their underlying channel(s) in the constructor,\n * and should assume that those channels are already connected. Decorators are\n * responsible for disposing of the channels they wrap when the decorators\n * themselves are disposed. Decorators should also follow the APIs of the\n * individual methods listed below.\n *\n */\n\n\ngoog.provide('goog.messaging.MessageChannel');\n\n\n\n/**\n * @interface\n */\ngoog.messaging.MessageChannel = function() {};\n\n\n/**\n * Initiates the channel connection. When this method is called, all the\n * information needed to connect the channel has to be available.\n *\n * Implementers should only require this method to be called if the channel\n * needs to be configured in some way between when it's created and when it\n * becomes active. Otherwise, the channel should be immediately active and this\n * method should do nothing but immediately call opt_connectCb.\n *\n * @param {Function=} opt_connectCb Called when the channel has been connected\n *     and is ready to use.\n */\ngoog.messaging.MessageChannel.prototype.connect = function(opt_connectCb) {};\n\n\n/**\n * Gets whether the channel is connected.\n *\n * If {@link #connect} is not required for this class, this should always return\n * true. Otherwise, this should return true by the time the callback passed to\n * {@link #connect} has been called and always after that.\n *\n * @return {boolean} Whether the channel is connected.\n */\ngoog.messaging.MessageChannel.prototype.isConnected = function() {};\n\n\n/**\n * Registers a service to be called when a message is received.\n *\n * Implementers shouldn't impose any restrictions on the service names that may\n * be registered. If some services are needed as control codes,\n * {@link goog.messaging.MultiMessageChannel} can be used to safely split the\n * channel into \"public\" and \"control\" virtual channels.\n *\n * @param {string} serviceName The name of the service.\n * @param {function((string|!Object))} callback The callback to process the\n *     incoming messages. Passed the payload. If opt_objectPayload is set, the\n *     payload is decoded and passed as an object.\n * @param {boolean=} opt_objectPayload If true, incoming messages for this\n *     service are expected to contain an object, and will be deserialized from\n *     a string automatically if necessary. It's the responsibility of\n *     implementors of this class to perform the deserialization.\n */\ngoog.messaging.MessageChannel.prototype.registerService = function(\n    serviceName, callback, opt_objectPayload) {};\n\n\n/**\n * Registers a service to be called when a message is received that doesn't\n * match any other services.\n *\n * @param {function(string, (string|!Object))} callback The callback to process\n *     the incoming messages. Passed the service name and the payload. Since\n *     some channels can pass objects natively, the payload may be either an\n *     object or a string.\n */\ngoog.messaging.MessageChannel.prototype.registerDefaultService = function(\n    callback) {};\n\n\n/**\n * Sends a message over the channel.\n *\n * @param {string} serviceName The name of the service this message should be\n *     delivered to.\n * @param {string|!Object} payload The value of the message. If this is an\n *     Object, it is serialized to a string before sending if necessary. It's\n *     the responsibility of implementors of this class to perform the\n *     serialization.\n */\ngoog.messaging.MessageChannel.prototype.send = function(serviceName, payload) {\n};\n"],
"names":["goog","provide","messaging","MessageChannel","goog.messaging.MessageChannel","prototype","connect","goog.messaging.MessageChannel.prototype.connect","opt_connectCb","isConnected","goog.messaging.MessageChannel.prototype.isConnected","registerService","goog.messaging.MessageChannel.prototype.registerService","serviceName","callback","opt_objectPayload","registerDefaultService","goog.messaging.MessageChannel.prototype.registerDefaultService","send","goog.messaging.MessageChannel.prototype.send","payload"]
}
