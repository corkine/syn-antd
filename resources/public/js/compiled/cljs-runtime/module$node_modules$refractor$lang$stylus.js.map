{
"version":3,
"file":"module$node_modules$refractor$lang$stylus.js",
"lineCount":4,
"mappings":"AAAAA,cAAA,0CAAA,CAA8D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,OAAhB,CAAwBC,MAAxB,CAA+BC,OAA/B,CAAuCC,YAAvC,CAAqD,CAM3HC,QAASA,OAAM,CAACC,KAAD,CAAQ,CAEnB,IAAIC,OAAS,CACXC,IAAK,sBADM,CAEXC,OAAQ,CACNC,QAAS,+CADH,CAENC,OAAQ,CAAA,CAFF,CAFG,CAMXC,cAAe,IANJ,CAQXC,KAAM,IARK,CAUXC,UAAW,8BAVA,CAWXC,QAAS,CACPL,QAAS,2DADF,CAEPM,WAAY,CAAA,CAFL,CAXE,CAeXC,QAAS,gBAfE,CAgBXC,OAAQ,mBAhBG,CAiBXC,QAAS,oBAjBE,CAkBXC,SAAU,CAGR,kGAHQ,CAlBC;AAuBXC,YAAa,eAvBF,CAyBbd,OAAA,cAAA,CAA0B,CACxBG,QAAS,gBADe,CAExBY,MAAO,UAFiB,CAGxBf,OAAQ,CACNgB,UAAW,CACTb,QAAS,OADA,CAETY,MAAO,aAFE,CADL,CAKNE,KAAMjB,MALA,CAHgB,CAW1BA,OAAA,KAAA,CAAiB,CACfG,QAAS,mBADM,CAEfH,OAAQ,CACNkB,SAAU,QADJ,CAEND,KAAMjB,MAFA,CAFO,CAmEhBD,MA5DDoB,UAAArB,OAAA,CAAyB,CACvBsB,QAAS,CACPjB,QAAS,oCADF,CAEPM,WAAY,CAAA,CAFL,CADc,CAKvB,qBAAsB,CACpBN,QAAS,YADW,CAEpBM,WAAY,CAAA,CAFQ,CAGpBT,OAAQ,CACNqB,OAAQ,UADF,CAENJ,KAAMjB,MAFA,CAHY,CALC,CAavB,uBAAwB,CACtBG,QAAS,qDADa;AAEtBM,WAAY,CAAA,CAFU,CAGtBT,OAAQ,CACNsB,SAAU,MADJ,CAENL,KAAMjB,MAFA,CAHc,CAbD,CAqBvBuB,UAAW,CACTpB,QAAS,iDADA,CAETM,WAAY,CAAA,CAFH,CAGTT,OAAQ,CACNQ,QAAS,MADH,CAENS,KAAMjB,MAFA,CAHC,CArBY,CA+BvB,uBAAwB,CACtBG,QAAS,yHADa,CAEtBM,WAAY,CAAA,CAFU,CAGtBT,OAAQ,CACNwB,SAAU,CACRrB,QAAS,UADD,CAERH,OAAQ,CACNK,cAAeL,MAAAK,cADT,CAFA,CADJ,CAONY,KAAMjB,MAPA,CAHc,CA/BD,CA+CvByB,SAAU,CACRtB,QAAS,sNADD;AAERM,WAAY,CAAA,CAFJ,CAGRT,OAAQ,CACNK,cAAeL,MAAAK,cADT,CAENS,YAAa,OAFP,CAHA,CA/Ca,CAuDvBR,KAAMN,MAAAM,KAvDiB,CAwDvBJ,OAAQF,MAAAE,OAxDe,CAyDvBG,cAAeL,MAAAK,cAzDQ,CA0DvBS,YAAa,eA1DU,CA7CN,CAHvBnB,MAAAC,QAAA,CAAiBE,MACjBA,OAAA4B,YAAA,CAAqB,QACrB5B,OAAA6B,QAAA,CAAiB,EAL0G;",
"sources":["node_modules/refractor/lang/stylus.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$refractor$lang$stylus\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict'\n\nmodule.exports = stylus\nstylus.displayName = 'stylus'\nstylus.aliases = []\nfunction stylus(Prism) {\n  ;(function(Prism) {\n    var inside = {\n      url: /url\\(([\"']?).*?\\1\\)/i,\n      string: {\n        pattern: /(\"|')(?:(?!\\1)[^\\\\\\r\\n]|\\\\(?:\\r\\n|[\\s\\S]))*\\1/,\n        greedy: true\n      },\n      interpolation: null,\n      // See below\n      func: null,\n      // See below\n      important: /\\B!(?:important|optional)\\b/i,\n      keyword: {\n        pattern: /(^|\\s+)(?:(?:if|else|for|return|unless)(?=\\s+|$)|@[\\w-]+)/,\n        lookbehind: true\n      },\n      hexcode: /#[\\da-f]{3,6}/i,\n      number: /\\b\\d+(?:\\.\\d+)?%?/,\n      boolean: /\\b(?:true|false)\\b/,\n      operator: [\n        // We want non-word chars around \"-\" because it is\n        // accepted in property names.\n        /~|[+!\\/%<>?=]=?|[-:]=|\\*[*=]?|\\.+|&&|\\|\\||\\B-\\B|\\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\\b/\n      ],\n      punctuation: /[{}()\\[\\];:,]/\n    }\n    inside['interpolation'] = {\n      pattern: /\\{[^\\r\\n}:]+\\}/,\n      alias: 'variable',\n      inside: {\n        delimiter: {\n          pattern: /^{|}$/,\n          alias: 'punctuation'\n        },\n        rest: inside\n      }\n    }\n    inside['func'] = {\n      pattern: /[\\w-]+\\([^)]*\\).*/,\n      inside: {\n        function: /^[^(]+/,\n        rest: inside\n      }\n    }\n    Prism.languages.stylus = {\n      comment: {\n        pattern: /(^|[^\\\\])(\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n        lookbehind: true\n      },\n      'atrule-declaration': {\n        pattern: /(^\\s*)@.+/m,\n        lookbehind: true,\n        inside: {\n          atrule: /^@[\\w-]+/,\n          rest: inside\n        }\n      },\n      'variable-declaration': {\n        pattern: /(^[ \\t]*)[\\w$-]+\\s*.?=[ \\t]*(?:(?:\\{[^}]*\\}|.+)|$)/m,\n        lookbehind: true,\n        inside: {\n          variable: /^\\S+/,\n          rest: inside\n        }\n      },\n      statement: {\n        pattern: /(^[ \\t]*)(?:if|else|for|return|unless)[ \\t]+.+/m,\n        lookbehind: true,\n        inside: {\n          keyword: /^\\S+/,\n          rest: inside\n        }\n      },\n      // A property/value pair cannot end with a comma or a brace\n      // It cannot have indented content unless it ended with a semicolon\n      'property-declaration': {\n        pattern: /((?:^|\\{)([ \\t]*))(?:[\\w-]|\\{[^}\\r\\n]+\\})+(?:\\s*:\\s*|[ \\t]+)[^{\\r\\n]*(?:;|[^{\\r\\n,](?=$)(?!(\\r?\\n|\\r)(?:\\{|\\2[ \\t]+)))/m,\n        lookbehind: true,\n        inside: {\n          property: {\n            pattern: /^[^\\s:]+/,\n            inside: {\n              interpolation: inside.interpolation\n            }\n          },\n          rest: inside\n        }\n      },\n      // A selector can contain parentheses only as part of a pseudo-element\n      // It can span multiple lines.\n      // It must end with a comma or an accolade or have indented content.\n      selector: {\n        pattern: /(^[ \\t]*)(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\))?|\\{[^}\\r\\n]+\\})+)(?:(?:\\r?\\n|\\r)(?:\\1(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\))?|\\{[^}\\r\\n]+\\})+)))*(?:,$|\\{|(?=(?:\\r?\\n|\\r)(?:\\{|\\1[ \\t]+)))/m,\n        lookbehind: true,\n        inside: {\n          interpolation: inside.interpolation,\n          punctuation: /[{},]/\n        }\n      },\n      func: inside.func,\n      string: inside.string,\n      interpolation: inside.interpolation,\n      punctuation: /[{}()\\[\\];:.]/\n    }\n  })(Prism)\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","stylus","Prism","inside","url","string","pattern","greedy","interpolation","func","important","keyword","lookbehind","hexcode","number","boolean","operator","punctuation","alias","delimiter","rest","function","languages","comment","atrule","variable","statement","property","selector","displayName","aliases"]
}
