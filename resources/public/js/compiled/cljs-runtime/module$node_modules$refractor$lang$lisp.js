shadow$provide.module$node_modules$refractor$lang$lisp=function(global,process,require,module,exports,shadow$shims){function lisp(Prism){var language={heading:{pattern:/;;;.*/,alias:["comment","title"]},comment:/;.*/,string:{pattern:/"(?:[^"\\]|\\.)*"/,greedy:!0,inside:{argument:/[-A-Z]+(?=[.,\s])/,symbol:/`[-+*/_~!@$%^=<>{}\w]+'/}},"quoted-symbol":{pattern:/#?'[-+*/_~!@$%^=<>{}\w]+/,alias:["variable","symbol"]},"lisp-property":{pattern:/:[-+*/_~!@$%^=<>{}\w]+/,alias:"property"},splice:{pattern:/,@?[-+*/_~!@$%^=<>{}\w]+/,
alias:["symbol","variable"]},keyword:[{pattern:/(\()(?:(?:lexical-)?let\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)(?=\s)/,lookbehind:!0},{pattern:/(\()(?:for|do|collect|return|finally|append|concat|in|by)(?=\s)/,lookbehind:!0}],declare:{pattern:/(\()declare(?=[\s\)])/,lookbehind:!0,alias:"keyword"},interactive:{pattern:/(\()interactive(?=[\s\)])/,lookbehind:!0,alias:"keyword"},boolean:{pattern:/([\s([])(?:t|nil)(?=[\s)])/,
lookbehind:!0},number:{pattern:/([\s([])[-+]?\d+(?:\.\d*)?(?=[\s)])/,lookbehind:!0},defvar:{pattern:/(\()def(?:var|const|custom|group)\s+[-+*/_~!@$%^=<>{}\w]+/,lookbehind:!0,inside:{keyword:/^def[a-z]+/,variable:/[-+*/_~!@$%^=<>{}\w]+/}},defun:{pattern:/(\()(?:cl-)?(?:defun\*?|defmacro)\s+[-+*/_~!@$%^=<>{}\w]+\s+\([\s\S]*?\)/,lookbehind:!0,inside:{keyword:/^(?:cl-)?def\S+/,arguments:null,function:{pattern:/(^\s)[-+*/_~!@$%^=<>{}\w]+/,lookbehind:!0},punctuation:/[()]/}},lambda:{pattern:/(\()lambda\s+\((?:&?[-+*/_~!@$%^=<>{}\w]+\s*)*\)/,
lookbehind:!0,inside:{keyword:/^lambda/,arguments:null,punctuation:/[()]/}},car:{pattern:/(\()[-+*/_~!@$%^=<>{}\w]+/,lookbehind:!0},punctuation:[/(['`,]?\(|[)\[\]])/,{pattern:/(\s)\.(?=\s)/,lookbehind:!0}]},arg={"lisp-marker":/&[-+*/_~!@$%^=<>{}\w]+/,rest:{argument:{pattern:/[-+*/_~!@$%^=<>{}\w]+/,alias:"variable"},varform:{pattern:/(\()[-+*/_~!@$%^=<>{}\w]+\s+\S[\s\S]*(?=\))/,lookbehind:!0,inside:{string:language.string,boolean:language.boolean,number:language.number,symbol:language.symbol,punctuation:/[()]/}}}};
arg={pattern:/(\()[\s\S]*(?=\))/,lookbehind:!0,inside:{"rest-vars":{pattern:/&(?:rest|body)\s+\S+(?:\s+\S+)*/,inside:arg},"other-marker-vars":{pattern:/&(?:optional|aux)\s+\S+(?:\s+\S+)*/,inside:arg},keys:{pattern:/&key\s+\S+(?:\s+\S+)*(?:\s+&allow-other-keys)?/,inside:arg},argument:{pattern:/[-+*/_~!@$%^=<>{}\w]+/,alias:"variable"},punctuation:/[()]/}};language.lambda.inside.arguments=arg;language.defun.inside.arguments=Prism.util.clone(arg);language.defun.inside.arguments.inside.sublist=arg;Prism.languages.lisp=
language;Prism.languages.elisp=language;Prism.languages.emacs=language;Prism.languages["emacs-lisp"]=language}module.exports=lisp;lisp.displayName="lisp";lisp.aliases=[]}
//# sourceMappingURL=module$node_modules$refractor$lang$lisp.js.map
