{
"version":3,
"file":"module$node_modules$refractor$lang$js_templates.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/refractor/lang/js-templates.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$refractor$lang$js_templates\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict'\n\nmodule.exports = jsTemplates\njsTemplates.displayName = 'jsTemplates'\njsTemplates.aliases = []\nfunction jsTemplates(Prism) {\n  ;(function(Prism) {\n    var templateString = Prism.languages.javascript['template-string'] // see the pattern in prism-javascript.js\n    var templateLiteralPattern = templateString.pattern.source\n    var interpolationObject = templateString.inside['interpolation']\n    var interpolationPunctuationObject =\n      interpolationObject.inside['interpolation-punctuation']\n    var interpolationPattern = interpolationObject.pattern.source\n    /**\n     * Creates a new pattern to match a template string with a special tag.\n     *\n     * This will return `undefined` if there is no grammar with the given language id.\n     *\n     * @param {string} language The language id of the embedded language. E.g. `markdown`.\n     * @param {string} tag The regex pattern to match the tag.\n     * @returns {object | undefined}\n     * @example\n     * createTemplate('css', /\\bcss/.source);\n     */\n    function createTemplate(language, tag) {\n      if (!Prism.languages[language]) {\n        return undefined\n      }\n      return {\n        pattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),\n        lookbehind: true,\n        greedy: true,\n        inside: {\n          'template-punctuation': {\n            pattern: /^`|`$/,\n            alias: 'string'\n          },\n          'embedded-code': {\n            pattern: /[\\s\\S]+/,\n            alias: language\n          }\n        }\n      }\n    }\n    Prism.languages.javascript['template-string'] = [\n      // styled-jsx:\n      //   css`a { color: #25F; }`\n      // styled-components:\n      //   styled.h1`color: red;`\n      createTemplate(\n        'css',\n        /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/\n          .source\n      ), // html`<p></p>`\n      // div.innerHTML = `<p></p>`\n      createTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source), // svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`\n      createTemplate('svg', /\\bsvg/.source), // md`# h1`, markdown`## h2`\n      createTemplate('markdown', /\\b(?:md|markdown)/.source), // gql`...`, graphql`...`, graphql.experimental`...`\n      createTemplate(\n        'graphql',\n        /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source\n      ), // vanilla template string\n      templateString\n    ].filter(Boolean)\n    /**\n     * Returns a specific placeholder literal for the given language.\n     *\n     * @param {number} counter\n     * @param {string} language\n     * @returns {string}\n     */\n    function getPlaceholder(counter, language) {\n      return '___' + language.toUpperCase() + '_' + counter + '___'\n    }\n    /**\n     * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.\n     *\n     * @param {string} code\n     * @param {any} grammar\n     * @param {string} language\n     * @returns {(string|Token)[]}\n     */\n    function tokenizeWithHooks(code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language\n      }\n      Prism.hooks.run('before-tokenize', env)\n      env.tokens = Prism.tokenize(env.code, env.grammar)\n      Prism.hooks.run('after-tokenize', env)\n      return env.tokens\n    }\n    /**\n     * Returns the token of the given JavaScript interpolation expression.\n     *\n     * @param {string} expression The code of the expression. E.g. `\"${42}\"`\n     * @returns {Token}\n     */\n    function tokenizeInterpolationExpression(expression) {\n      var tempGrammar = {}\n      tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject\n      /** @type {Array} */\n      var tokens = Prism.tokenize(expression, tempGrammar)\n      if (tokens.length === 3) {\n        /**\n         * The token array will look like this\n         * [\n         *     [\"interpolation-punctuation\", \"${\"]\n         *     \"...\" // JavaScript expression of the interpolation\n         *     [\"interpolation-punctuation\", \"}\"]\n         * ]\n         */\n        var args = [1, 1]\n        args.push.apply(\n          args,\n          tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript')\n        )\n        tokens.splice.apply(tokens, args)\n      }\n      return new Prism.Token(\n        'interpolation',\n        tokens,\n        interpolationObject.alias,\n        expression\n      )\n    }\n    /**\n     * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.\n     *\n     * This function has 3 phases:\n     *\n     * 1. Replace all JavaScript interpolation expression with a placeholder.\n     *    The placeholder will have the syntax of a identify of the target language.\n     * 2. Tokenize the code with placeholders.\n     * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.\n     *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been\n     *    tokenized as two tokens by the grammar of the embedded language.\n     *\n     * @param {string} code\n     * @param {object} grammar\n     * @param {string} language\n     * @returns {Token}\n     */\n    function tokenizeEmbedded(code, grammar, language) {\n      // 1. First filter out all interpolations\n      // because they might be escaped, we need a lookbehind, so we use Prism\n      /** @type {(Token|string)[]} */\n      var _tokens = Prism.tokenize(code, {\n        interpolation: {\n          pattern: RegExp(interpolationPattern),\n          lookbehind: true\n        }\n      }) // replace all interpolations with a placeholder which is not in the code already\n      var placeholderCounter = 0\n      /** @type {Object<string, string>} */\n      var placeholderMap = {}\n      var embeddedCode = _tokens\n        .map(function(token) {\n          if (typeof token === 'string') {\n            return token\n          } else {\n            var interpolationExpression = token.content\n            var placeholder\n            while (\n              code.indexOf(\n                (placeholder = getPlaceholder(placeholderCounter++, language))\n              ) !== -1\n            ) {}\n            placeholderMap[placeholder] = interpolationExpression\n            return placeholder\n          }\n        })\n        .join('') // 2. Tokenize the embedded code\n      var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language) // 3. Re-insert the interpolation\n      var placeholders = Object.keys(placeholderMap)\n      placeholderCounter = 0\n      /**\n       *\n       * @param {(Token|string)[]} tokens\n       * @returns {void}\n       */\n      function walkTokens(tokens) {\n        for (var i = 0; i < tokens.length; i++) {\n          if (placeholderCounter >= placeholders.length) {\n            return\n          }\n          var token = tokens[i]\n          if (typeof token === 'string' || typeof token.content === 'string') {\n            var placeholder = placeholders[placeholderCounter]\n            var s =\n              typeof token === 'string'\n                ? token\n                : /** @type {string} */\n                  token.content\n            var index = s.indexOf(placeholder)\n            if (index !== -1) {\n              ++placeholderCounter\n              var before = s.substring(0, index)\n              var middle = tokenizeInterpolationExpression(\n                placeholderMap[placeholder]\n              )\n              var after = s.substring(index + placeholder.length)\n              var replacement = []\n              if (before) {\n                replacement.push(before)\n              }\n              replacement.push(middle)\n              if (after) {\n                var afterTokens = [after]\n                walkTokens(afterTokens)\n                replacement.push.apply(replacement, afterTokens)\n              }\n              if (typeof token === 'string') {\n                tokens.splice.apply(tokens, [i, 1].concat(replacement))\n                i += replacement.length - 1\n              } else {\n                token.content = replacement\n              }\n            }\n          } else {\n            var content = token.content\n            if (Array.isArray(content)) {\n              walkTokens(content)\n            } else {\n              walkTokens([content])\n            }\n          }\n        }\n      }\n      walkTokens(embeddedTokens)\n      return new Prism.Token(\n        language,\n        embeddedTokens,\n        'language-' + language,\n        code\n      )\n    }\n    /**\n     * The languages for which JS templating will handle tagged template literals.\n     *\n     * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.\n     */\n    var supportedLanguages = {\n      javascript: true,\n      js: true,\n      typescript: true,\n      ts: true,\n      jsx: true,\n      tsx: true\n    }\n    Prism.hooks.add('after-tokenize', function(env) {\n      if (!(env.language in supportedLanguages)) {\n        return\n      }\n      /**\n       * Finds and tokenizes all template strings with an embedded languages.\n       *\n       * @param {(Token | string)[]} tokens\n       * @returns {void}\n       */\n      function findTemplateStrings(tokens) {\n        for (var i = 0, l = tokens.length; i < l; i++) {\n          var token = tokens[i]\n          if (typeof token === 'string') {\n            continue\n          }\n          var content = token.content\n          if (!Array.isArray(content)) {\n            if (typeof content !== 'string') {\n              findTemplateStrings([content])\n            }\n            continue\n          }\n          if (token.type === 'template-string') {\n            /**\n             * A JavaScript template-string token will look like this:\n             *\n             * [\"template-string\", [\n             *     [\"template-punctuation\", \"`\"],\n             *     (\n             *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.\n             *         or\n             *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.\n             *                                  It also has an alias which is the language of the embedded code.\n             *     ),\n             *     [\"template-punctuation\", \"`\"]\n             * ]]\n             */\n            var embedded = content[1]\n            if (\n              content.length === 3 &&\n              typeof embedded !== 'string' &&\n              embedded.type === 'embedded-code'\n            ) {\n              // get string content\n              var code = stringContent(embedded)\n              var alias = embedded.alias\n              var language = Array.isArray(alias) ? alias[0] : alias\n              var grammar = Prism.languages[language]\n              if (!grammar) {\n                // the embedded language isn't registered.\n                continue\n              }\n              content[1] = tokenizeEmbedded(code, grammar, language)\n            }\n          } else {\n            findTemplateStrings(content)\n          }\n        }\n      }\n      findTemplateStrings(env.tokens)\n    })\n    /**\n     * Returns the string content of a token or token stream.\n     *\n     * @param {string | Token | (string | Token)[]} value\n     * @returns {string}\n     */\n    function stringContent(value) {\n      if (typeof value === 'string') {\n        return value\n      } else if (Array.isArray(value)) {\n        return value.map(stringContent).join('')\n      } else {\n        return stringContent(value.content)\n      }\n    }\n  })(Prism)\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","jsTemplates","Prism","createTemplate","language","tag","languages","pattern","RegExp","templateLiteralPattern","lookbehind","greedy","inside","alias","getPlaceholder","counter","toUpperCase","tokenizeWithHooks","code","grammar","env","hooks","run","tokens","tokenize","tokenizeEmbedded","walkTokens","i","length","placeholderCounter","placeholders","token","content","placeholder","s","index","indexOf","before","substring","placeholderMap","tempGrammar","interpolationPunctuationObject","expression","args","push","apply","javascript","splice","Token","interpolationObject","after","replacement","middle","afterTokens","concat","Array","isArray","embeddedCode","_tokens","interpolation","interpolationPattern","map","interpolationExpression","join","embeddedTokens","Object","keys","stringContent","value","templateString","source","filter","Boolean","supportedLanguages","js","typescript","ts","jsx","tsx","add","findTemplateStrings","l","type","embedded","displayName","aliases"]
}
