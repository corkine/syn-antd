{
"version":3,
"file":"module$node_modules$refractor$lang$lisp.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/refractor/lang/lisp.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$refractor$lang$lisp\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict'\n\nmodule.exports = lisp\nlisp.displayName = 'lisp'\nlisp.aliases = []\nfunction lisp(Prism) {\n  ;(function(Prism) {\n    // Functions to construct regular expressions\n    // simple form\n    // e.g. (interactive ... or (interactive)\n    function simple_form(name) {\n      return RegExp('(\\\\()' + name + '(?=[\\\\s\\\\)])')\n    } // booleans and numbers\n    function primitive(pattern) {\n      return RegExp('([\\\\s([])' + pattern + '(?=[\\\\s)])')\n    } // Patterns in regular expressions\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\n    // & and : are excluded as they are usually used for special purposes\n    var symbol = '[-+*/_~!@$%^=<>{}\\\\w]+' // symbol starting with & used in function arguments\n    var marker = '&' + symbol // Open parenthesis for look-behind\n    var par = '(\\\\()'\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\n    var space = '(?=\\\\s)'\n    var language = {\n      // Three or four semicolons are considered a heading.\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\n      heading: {\n        pattern: /;;;.*/,\n        alias: ['comment', 'title']\n      },\n      comment: /;.*/,\n      string: {\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n        greedy: true,\n        inside: {\n          argument: /[-A-Z]+(?=[.,\\s])/,\n          symbol: RegExp('`' + symbol + \"'\")\n        }\n      },\n      'quoted-symbol': {\n        pattern: RegExp(\"#?'\" + symbol),\n        alias: ['variable', 'symbol']\n      },\n      'lisp-property': {\n        pattern: RegExp(':' + symbol),\n        alias: 'property'\n      },\n      splice: {\n        pattern: RegExp(',@?' + symbol),\n        alias: ['symbol', 'variable']\n      },\n      keyword: [\n        {\n          pattern: RegExp(\n            par +\n              '(?:(?:lexical-)?let\\\\*?|(?:cl-)?letf|if|when|while|unless|cons|cl-loop|and|or|not|cond|setq|error|message|null|require|provide|use-package)' +\n              space\n          ),\n          lookbehind: true\n        },\n        {\n          pattern: RegExp(\n            par +\n              '(?:for|do|collect|return|finally|append|concat|in|by)' +\n              space\n          ),\n          lookbehind: true\n        }\n      ],\n      declare: {\n        pattern: simple_form('declare'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      interactive: {\n        pattern: simple_form('interactive'),\n        lookbehind: true,\n        alias: 'keyword'\n      },\n      boolean: {\n        pattern: primitive('(?:t|nil)'),\n        lookbehind: true\n      },\n      number: {\n        pattern: primitive('[-+]?\\\\d+(?:\\\\.\\\\d*)?'),\n        lookbehind: true\n      },\n      defvar: {\n        pattern: RegExp(par + 'def(?:var|const|custom|group)\\\\s+' + symbol),\n        lookbehind: true,\n        inside: {\n          keyword: /^def[a-z]+/,\n          variable: RegExp(symbol)\n        }\n      },\n      defun: {\n        pattern: RegExp(\n          par +\n            '(?:cl-)?(?:defun\\\\*?|defmacro)\\\\s+' +\n            symbol +\n            '\\\\s+\\\\([\\\\s\\\\S]*?\\\\)'\n        ),\n        lookbehind: true,\n        inside: {\n          keyword: /^(?:cl-)?def\\S+/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          function: {\n            pattern: RegExp('(^\\\\s)' + symbol),\n            lookbehind: true\n          },\n          punctuation: /[()]/\n        }\n      },\n      lambda: {\n        pattern: RegExp(par + 'lambda\\\\s+\\\\((?:&?' + symbol + '\\\\s*)*\\\\)'),\n        lookbehind: true,\n        inside: {\n          keyword: /^lambda/,\n          // See below, this property needs to be defined later so that it can\n          // reference the language object.\n          arguments: null,\n          punctuation: /[()]/\n        }\n      },\n      car: {\n        pattern: RegExp(par + symbol),\n        lookbehind: true\n      },\n      punctuation: [\n        // open paren, brackets, and close paren\n        /(['`,]?\\(|[)\\[\\]])/, // cons\n        {\n          pattern: /(\\s)\\.(?=\\s)/,\n          lookbehind: true\n        }\n      ]\n    }\n    var arg = {\n      'lisp-marker': RegExp(marker),\n      rest: {\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        varform: {\n          pattern: RegExp(par + symbol + '\\\\s+\\\\S[\\\\s\\\\S]*' + endpar),\n          lookbehind: true,\n          inside: {\n            string: language.string,\n            boolean: language.boolean,\n            number: language.number,\n            symbol: language.symbol,\n            punctuation: /[()]/\n          }\n        }\n      }\n    }\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\n    var arglist = {\n      pattern: RegExp(par + '[\\\\s\\\\S]*' + endpar),\n      lookbehind: true,\n      inside: {\n        'rest-vars': {\n          pattern: RegExp('&(?:rest|body)\\\\s+' + forms),\n          inside: arg\n        },\n        'other-marker-vars': {\n          pattern: RegExp('&(?:optional|aux)\\\\s+' + forms),\n          inside: arg\n        },\n        keys: {\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\n          inside: arg\n        },\n        argument: {\n          pattern: RegExp(symbol),\n          alias: 'variable'\n        },\n        punctuation: /[()]/\n      }\n    }\n    language['lambda'].inside.arguments = arglist\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\n    language['defun'].inside.arguments.inside.sublist = arglist\n    Prism.languages.lisp = language\n    Prism.languages.elisp = language\n    Prism.languages.emacs = language\n    Prism.languages['emacs-lisp'] = language\n  })(Prism)\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","lisp","Prism","language","heading","pattern","alias","comment","string","greedy","inside","argument","symbol","splice","keyword","lookbehind","declare","interactive","boolean","number","defvar","variable","defun","arguments","function","punctuation","lambda","car","arg","rest","varform","arglist","keys","util","clone","sublist","languages","elisp","emacs","displayName","aliases"]
}
