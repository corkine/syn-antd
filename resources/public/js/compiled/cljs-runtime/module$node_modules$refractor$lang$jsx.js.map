{
"version":3,
"file":"module$node_modules$refractor$lang$jsx.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/refractor/lang/jsx.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$refractor$lang$jsx\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict'\n\nmodule.exports = jsx\njsx.displayName = 'jsx'\njsx.aliases = []\nfunction jsx(Prism) {\n  ;(function(Prism) {\n    var javascript = Prism.util.clone(Prism.languages.javascript)\n    Prism.languages.jsx = Prism.languages.extend('markup', javascript)\n    Prism.languages.jsx.tag.pattern = /<\\/?(?:[\\w.:-]+\\s*(?:\\s+(?:[\\w.:-]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s{'\">=]+|\\{(?:\\{(?:\\{[^}]*\\}|[^{}])*\\}|[^{}])+\\}))?|\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}))*\\s*\\/?)?>/i\n    Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i\n    Prism.languages.jsx.tag.inside[\n      'attr-value'\n    ].pattern = /=(?!\\{)(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">]+)/i\n    Prism.languages.jsx.tag.inside['tag'].inside[\n      'class-name'\n    ] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-name',\n      {\n        spread: {\n          pattern: /\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}/,\n          inside: {\n            punctuation: /\\.{3}|[{}.]/,\n            'attr-value': /\\w+/\n          }\n        }\n      },\n      Prism.languages.jsx.tag\n    )\n    Prism.languages.insertBefore(\n      'inside',\n      'attr-value',\n      {\n        script: {\n          // Allow for two levels of nesting\n          pattern: /=(\\{(?:\\{(?:\\{[^}]*\\}|[^}])*\\}|[^}])+\\})/i,\n          inside: {\n            'script-punctuation': {\n              pattern: /^=(?={)/,\n              alias: 'punctuation'\n            },\n            rest: Prism.languages.jsx\n          },\n          alias: 'language-javascript'\n        }\n      },\n      Prism.languages.jsx.tag\n    ) // The following will handle plain text inside tags\n    var stringifyToken = function(token) {\n      if (!token) {\n        return ''\n      }\n      if (typeof token === 'string') {\n        return token\n      }\n      if (typeof token.content === 'string') {\n        return token.content\n      }\n      return token.content.map(stringifyToken).join('')\n    }\n    var walkTokens = function(tokens) {\n      var openedTags = []\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i]\n        var notTagNorBrace = false\n        if (typeof token !== 'string') {\n          if (\n            token.type === 'tag' &&\n            token.content[0] &&\n            token.content[0].type === 'tag'\n          ) {\n            // We found a tag, now find its kind\n            if (token.content[0].content[0].content === '</') {\n              // Closing tag\n              if (\n                openedTags.length > 0 &&\n                openedTags[openedTags.length - 1].tagName ===\n                  stringifyToken(token.content[0].content[1])\n              ) {\n                // Pop matching opening tag\n                openedTags.pop()\n              }\n            } else {\n              if (token.content[token.content.length - 1].content === '/>') {\n                // Autoclosed tag, ignore\n              } else {\n                // Opening tag\n                openedTags.push({\n                  tagName: stringifyToken(token.content[0].content[1]),\n                  openedBraces: 0\n                })\n              }\n            }\n          } else if (\n            openedTags.length > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '{'\n          ) {\n            // Here we might have entered a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces++\n          } else if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces > 0 &&\n            token.type === 'punctuation' &&\n            token.content === '}'\n          ) {\n            // Here we might have left a JSX context inside a tag\n            openedTags[openedTags.length - 1].openedBraces--\n          } else {\n            notTagNorBrace = true\n          }\n        }\n        if (notTagNorBrace || typeof token === 'string') {\n          if (\n            openedTags.length > 0 &&\n            openedTags[openedTags.length - 1].openedBraces === 0\n          ) {\n            // Here we are inside a tag, and not inside a JSX context.\n            // That's plain text: drop any tokens matched.\n            var plainText = stringifyToken(token) // And merge text with adjacent text\n            if (\n              i < tokens.length - 1 &&\n              (typeof tokens[i + 1] === 'string' ||\n                tokens[i + 1].type === 'plain-text')\n            ) {\n              plainText += stringifyToken(tokens[i + 1])\n              tokens.splice(i + 1, 1)\n            }\n            if (\n              i > 0 &&\n              (typeof tokens[i - 1] === 'string' ||\n                tokens[i - 1].type === 'plain-text')\n            ) {\n              plainText = stringifyToken(tokens[i - 1]) + plainText\n              tokens.splice(i - 1, 1)\n              i--\n            }\n            tokens[i] = new Prism.Token(\n              'plain-text',\n              plainText,\n              null,\n              plainText\n            )\n          }\n        }\n        if (token.content && typeof token.content !== 'string') {\n          walkTokens(token.content)\n        }\n      }\n    }\n    Prism.hooks.add('after-tokenize', function(env) {\n      if (env.language !== 'jsx' && env.language !== 'tsx') {\n        return\n      }\n      walkTokens(env.tokens)\n    })\n  })(Prism)\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","jsx","Prism","javascript","util","clone","languages","extend","tag","pattern","inside","insertBefore","spread","punctuation","script","alias","rest","stringifyToken","token","content","map","join","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","Token","hooks","add","env","language","displayName","aliases"]
}
