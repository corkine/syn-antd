{
"version":3,
"file":"module$node_modules$lowlight$lib$core.js",
"lineCount":18,
"mappings":"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",
"sources":["node_modules/lowlight/lib/core.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$lowlight$lib$core\"] = function(global,process,require,module,exports,shadow$shims) {\n'use strict'\n\nvar high = require('highlight.js/lib/highlight.js')\nvar fault = require('fault')\n\n/* The lowlight interface, which has to be compatible\n * with highlight.js, as this object is passed to\n * highlight.js syntaxes. */\n\nfunction High() {}\n\nHigh.prototype = high\n\n/* Expose. */\nvar low = new High() // Ha!\n\nmodule.exports = low\n\nlow.highlight = highlight\nlow.highlightAuto = autoHighlight\nlow.registerLanguage = registerLanguage\nlow.registerAlias = registerAlias\nlow.getLanguage = getLanguage\n\nvar inherit = high.inherit\nvar own = {}.hasOwnProperty\nvar concat = [].concat\n\nvar defaultPrefix = 'hljs-'\nvar keyInsensitive = 'case_insensitive'\nvar keyCachedVariants = 'cached_variants'\nvar space = ' '\nvar pipe = '|'\n\nvar T_ELEMENT = 'element'\nvar T_TEXT = 'text'\nvar T_SPAN = 'span'\n\n/* Maps of syntaxes. */\nvar languageNames = []\nvar languages = {}\nvar aliases = {}\n\n/* Highlighting with language detection.  Accepts a string\n * with the code to highlight.  Returns an object with the\n * following properties:\n *\n * - language (detected language)\n * - relevance (int)\n * - value (a HAST tree with highlighting markup)\n * - secondBest (object with the same structure for\n *   second-best heuristically detected language, may\n *   be absent) */\nfunction autoHighlight(value, options) {\n  var settings = options || {}\n  var subset = settings.subset || languageNames\n  var prefix = settings.prefix\n  var length = subset.length\n  var index = -1\n  var result\n  var secondBest\n  var current\n  var name\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  secondBest = normalize({})\n  result = normalize({})\n\n  while (++index < length) {\n    name = subset[index]\n\n    if (!getLanguage(name)) {\n      continue\n    }\n\n    current = normalize(coreHighlight(name, value, false, prefix))\n\n    current.language = name\n\n    if (current.relevance > secondBest.relevance) {\n      secondBest = current\n    }\n\n    if (current.relevance > result.relevance) {\n      secondBest = result\n      result = current\n    }\n  }\n\n  if (secondBest.language) {\n    result.secondBest = secondBest\n  }\n\n  return result\n}\n\n/* Highlighting `value` in the language `language`. */\nfunction highlight(language, value, options) {\n  var settings = options || {}\n  var prefix = settings.prefix\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  return normalize(coreHighlight(language, value, true, prefix))\n}\n\n/* Register a language. */\nfunction registerLanguage(name, syntax) {\n  var lang = syntax(low)\n\n  languages[name] = lang\n\n  languageNames.push(name)\n\n  if (lang.aliases) {\n    registerAlias(name, lang.aliases)\n  }\n}\n\n/* Register more aliases for an already registered language. */\nfunction registerAlias(name, alias) {\n  var map = name\n  var key\n  var list\n  var length\n  var index\n\n  if (alias) {\n    map = {}\n    map[name] = alias\n  }\n\n  for (key in map) {\n    list = map[key]\n    list = typeof list === 'string' ? [list] : list\n    length = list.length\n    index = -1\n\n    while (++index < length) {\n      aliases[list[index]] = key\n    }\n  }\n}\n\n/* Core highlighting function.  Accepts a language name, or\n * an alias, and a string with the code to highlight.\n * Returns an object with the following properties: */\nfunction coreHighlight(name, value, ignore, prefix, continuation) {\n  var continuations = {}\n  var stack = []\n  var modeBuffer = ''\n  var relevance = 0\n  var language\n  var top\n  var current\n  var currentChildren\n  var offset\n  var count\n  var match\n  var children\n\n  if (typeof name !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', name)\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  language = getLanguage(name)\n  top = continuation || language\n  children = []\n\n  current = top\n  currentChildren = children\n\n  if (!language) {\n    throw fault('Unknown language: `%s` is not registered', name)\n  }\n\n  compileLanguage(language)\n\n  try {\n    top.terminators.lastIndex = 0\n    offset = 0\n    match = top.terminators.exec(value)\n\n    while (match) {\n      count = processLexeme(value.substring(offset, match.index), match[0])\n      offset = match.index + count\n      top.terminators.lastIndex = offset\n      match = top.terminators.exec(value)\n    }\n\n    processLexeme(value.substr(offset))\n    current = top\n\n    while (current.parent) {\n      if (current.className) {\n        pop()\n      }\n\n      current = current.parent\n    }\n\n    return {\n      relevance: relevance,\n      value: currentChildren,\n      language: name,\n      top: top\n    }\n  } catch (error) {\n    /* istanbul ignore if - Catch-all  */\n    if (error.message.indexOf('Illegal') === -1) {\n      throw error\n    }\n\n    return {relevance: 0, value: addText(value, [])}\n  }\n\n  /* Process a lexeme.  Returns next position. */\n  function processLexeme(buffer, lexeme) {\n    var newMode\n    var endMode\n    var origin\n\n    modeBuffer += buffer\n\n    if (lexeme === undefined) {\n      addSiblings(processBuffer(), currentChildren)\n\n      return 0\n    }\n\n    newMode = subMode(lexeme, top)\n\n    if (newMode) {\n      addSiblings(processBuffer(), currentChildren)\n\n      startNewMode(newMode, lexeme)\n\n      return newMode.returnBegin ? 0 : lexeme.length\n    }\n\n    endMode = endOfMode(top, lexeme)\n\n    if (endMode) {\n      origin = top\n\n      if (!(origin.returnEnd || origin.excludeEnd)) {\n        modeBuffer += lexeme\n      }\n\n      addSiblings(processBuffer(), currentChildren)\n\n      /* Close open modes. */\n      do {\n        if (top.className) {\n          pop()\n        }\n\n        relevance += top.relevance\n        top = top.parent\n      } while (top !== endMode.parent)\n\n      if (origin.excludeEnd) {\n        addText(lexeme, currentChildren)\n      }\n\n      modeBuffer = ''\n\n      if (endMode.starts) {\n        startNewMode(endMode.starts, '')\n      }\n\n      return origin.returnEnd ? 0 : lexeme.length\n    }\n\n    if (isIllegal(lexeme, top)) {\n      throw fault(\n        'Illegal lexeme \"%s\" for mode \"%s\"',\n        lexeme,\n        top.className || '<unnamed>'\n      )\n    }\n\n    /* Parser should not reach this point as all\n     * types of lexemes should be caught earlier,\n     * but if it does due to some bug make sure it\n     * advances at least one character forward to\n     * prevent infinite looping. */\n    modeBuffer += lexeme\n\n    return lexeme.length || /* istanbul ignore next */ 1\n  }\n\n  /* Start a new mode with a `lexeme` to process. */\n  function startNewMode(mode, lexeme) {\n    var node\n\n    if (mode.className) {\n      node = build(mode.className, [])\n    }\n\n    if (mode.returnBegin) {\n      modeBuffer = ''\n    } else if (mode.excludeBegin) {\n      addText(lexeme, currentChildren)\n\n      modeBuffer = ''\n    } else {\n      modeBuffer = lexeme\n    }\n\n    /* Enter a new mode. */\n    if (node) {\n      currentChildren.push(node)\n      stack.push(currentChildren)\n      currentChildren = node.children\n    }\n\n    top = Object.create(mode, {parent: {value: top}})\n  }\n\n  /* Process the buffer. */\n  function processBuffer() {\n    var result = top.subLanguage ? processSubLanguage() : processKeywords()\n    modeBuffer = ''\n    return result\n  }\n\n  /* Process a sublanguage (returns a list of nodes). */\n  function processSubLanguage() {\n    var explicit = typeof top.subLanguage === 'string'\n    var subvalue\n\n    /* istanbul ignore if - support non-loaded sublanguages */\n    if (explicit && !languages[top.subLanguage]) {\n      return addText(modeBuffer, [])\n    }\n\n    if (explicit) {\n      subvalue = coreHighlight(\n        top.subLanguage,\n        modeBuffer,\n        true,\n        prefix,\n        continuations[top.subLanguage]\n      )\n    } else {\n      subvalue = autoHighlight(modeBuffer, {\n        subset: top.subLanguage.length === 0 ? undefined : top.subLanguage,\n        prefix: prefix\n      })\n    }\n\n    /* Counting embedded language score towards the\n     * host language may be disabled with zeroing the\n     * containing mode relevance.  Usecase in point is\n     * Markdown that allows XML everywhere and makes\n     * every XML snippet to have a much larger Markdown\n     * score. */\n    if (top.relevance > 0) {\n      relevance += subvalue.relevance\n    }\n\n    if (explicit) {\n      continuations[top.subLanguage] = subvalue.top\n    }\n\n    return [build(subvalue.language, subvalue.value, true)]\n  }\n\n  /* Process keywords. Returns nodes. */\n  function processKeywords() {\n    var nodes = []\n    var lastIndex\n    var keyword\n    var node\n    var submatch\n\n    if (!top.keywords) {\n      return addText(modeBuffer, nodes)\n    }\n\n    lastIndex = 0\n\n    top.lexemesRe.lastIndex = 0\n\n    keyword = top.lexemesRe.exec(modeBuffer)\n\n    while (keyword) {\n      addText(modeBuffer.substring(lastIndex, keyword.index), nodes)\n\n      submatch = keywordMatch(top, keyword)\n\n      if (submatch) {\n        relevance += submatch[1]\n\n        node = build(submatch[0], [])\n\n        nodes.push(node)\n\n        addText(keyword[0], node.children)\n      } else {\n        addText(keyword[0], nodes)\n      }\n\n      lastIndex = top.lexemesRe.lastIndex\n      keyword = top.lexemesRe.exec(modeBuffer)\n    }\n\n    addText(modeBuffer.substr(lastIndex), nodes)\n\n    return nodes\n  }\n\n  /* Add siblings. */\n  function addSiblings(siblings, nodes) {\n    var length = siblings.length\n    var index = -1\n    var sibling\n\n    while (++index < length) {\n      sibling = siblings[index]\n\n      if (sibling.type === T_TEXT) {\n        addText(sibling.value, nodes)\n      } else {\n        nodes.push(sibling)\n      }\n    }\n  }\n\n  /* Add a text. */\n  function addText(value, nodes) {\n    var tail\n\n    if (value) {\n      tail = nodes[nodes.length - 1]\n\n      if (tail && tail.type === T_TEXT) {\n        tail.value += value\n      } else {\n        nodes.push(buildText(value))\n      }\n    }\n\n    return nodes\n  }\n\n  /* Build a text. */\n  function buildText(value) {\n    return {type: T_TEXT, value: value}\n  }\n\n  /* Build a span. */\n  function build(name, contents, noPrefix) {\n    return {\n      type: T_ELEMENT,\n      tagName: T_SPAN,\n      properties: {\n        className: [(noPrefix ? '' : prefix) + name]\n      },\n      children: contents\n    }\n  }\n\n  /* Check if the first word in `keywords` is a keyword. */\n  function keywordMatch(mode, keywords) {\n    var keyword = keywords[0]\n\n    if (language[keyInsensitive]) {\n      keyword = keyword.toLowerCase()\n    }\n\n    return own.call(mode.keywords, keyword) && mode.keywords[keyword]\n  }\n\n  /* Check if `lexeme` is illegal according to `mode`. */\n  function isIllegal(lexeme, mode) {\n    return !ignore && test(mode.illegalRe, lexeme)\n  }\n\n  /* Check if `lexeme` ends `mode`. */\n  function endOfMode(mode, lexeme) {\n    if (test(mode.endRe, lexeme)) {\n      while (mode.endsParent && mode.parent) {\n        mode = mode.parent\n      }\n\n      return mode\n    }\n\n    if (mode.endsWithParent) {\n      return endOfMode(mode.parent, lexeme)\n    }\n  }\n\n  /* Check a sub-mode. */\n  function subMode(lexeme, mode) {\n    var values = mode.contains\n    var length = values.length\n    var index = -1\n\n    while (++index < length) {\n      if (test(values[index].beginRe, lexeme)) {\n        return values[index]\n      }\n    }\n  }\n\n  /* Exit the current context. */\n  function pop() {\n    /* istanbul ignore next - removed in hljs 9.3 */\n    currentChildren = stack.pop() || children\n  }\n}\n\nfunction expandMode(mode) {\n  var length\n  var index\n  var variants\n  var result\n\n  if (mode.variants && !mode[keyCachedVariants]) {\n    variants = mode.variants\n    length = variants.length\n    index = -1\n    result = []\n\n    while (++index < length) {\n      result[index] = inherit(mode, {variants: null}, variants[index])\n    }\n\n    mode[keyCachedVariants] = result\n  }\n\n  return (\n    mode[keyCachedVariants] || (mode.endsWithParent ? [inherit(mode)] : [mode])\n  )\n}\n\n/* Compile a language. */\nfunction compileLanguage(language) {\n  compileMode(language)\n\n  /* Compile a language mode, optionally with a parent. */\n  function compileMode(mode, parent) {\n    var compiledKeywords = {}\n    var terminators\n\n    if (mode.compiled) {\n      return\n    }\n\n    mode.compiled = true\n\n    mode.keywords = mode.keywords || mode.beginKeywords\n\n    if (mode.keywords) {\n      if (typeof mode.keywords === 'string') {\n        flatten('keyword', mode.keywords)\n      } else {\n        Object.keys(mode.keywords).forEach(function(className) {\n          flatten(className, mode.keywords[className])\n        })\n      }\n\n      mode.keywords = compiledKeywords\n    }\n\n    mode.lexemesRe = langRe(mode.lexemes || /\\w+/, true)\n\n    if (parent) {\n      if (mode.beginKeywords) {\n        mode.begin =\n          '\\\\b(' + mode.beginKeywords.split(space).join(pipe) + ')\\\\b'\n      }\n\n      if (!mode.begin) {\n        mode.begin = /\\B|\\b/\n      }\n\n      mode.beginRe = langRe(mode.begin)\n\n      if (!mode.end && !mode.endsWithParent) {\n        mode.end = /\\B|\\b/\n      }\n\n      if (mode.end) {\n        mode.endRe = langRe(mode.end)\n      }\n\n      mode.terminatorEnd = source(mode.end) || ''\n\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        mode.terminatorEnd += (mode.end ? pipe : '') + parent.terminatorEnd\n      }\n    }\n\n    if (mode.illegal) {\n      mode.illegalRe = langRe(mode.illegal)\n    }\n\n    if (mode.relevance === undefined) {\n      mode.relevance = 1\n    }\n\n    if (!mode.contains) {\n      mode.contains = []\n    }\n\n    mode.contains = concat.apply(\n      [],\n      mode.contains.map(function(c) {\n        return expandMode(c === 'self' ? mode : c)\n      })\n    )\n\n    mode.contains.forEach(function(c) {\n      compileMode(c, mode)\n    })\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent)\n    }\n\n    terminators = mode.contains\n      .map(map)\n      .concat([mode.terminatorEnd, mode.illegal])\n      .map(source)\n      .filter(Boolean)\n\n    mode.terminators =\n      terminators.length === 0\n        ? {exec: execNoop}\n        : langRe(terminators.join(pipe), true)\n\n    function map(c) {\n      return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin\n    }\n\n    /* Flatten a classname. */\n    function flatten(className, value) {\n      var pairs\n      var pair\n      var index\n      var length\n\n      if (language[keyInsensitive]) {\n        value = value.toLowerCase()\n      }\n\n      pairs = value.split(space)\n      length = pairs.length\n      index = -1\n\n      while (++index < length) {\n        pair = pairs[index].split(pipe)\n\n        compiledKeywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1]\n      }\n    }\n  }\n\n  /* Create a regex for `value`. */\n  function langRe(value, global) {\n    return new RegExp(\n      source(value),\n      'm' + (language[keyInsensitive] ? 'i' : '') + (global ? 'g' : '')\n    )\n  }\n\n  /* Get the source of an expression or string. */\n  function source(re) {\n    return (re && re.source) || re\n  }\n}\n\n/* Normalize a syntax result. */\nfunction normalize(result) {\n  return {\n    relevance: result.relevance || 0,\n    language: result.language || null,\n    value: result.value || []\n  }\n}\n\n/* Check if `expression` matches `lexeme`. */\nfunction test(expression, lexeme) {\n  var match = expression && expression.exec(lexeme)\n  return match && match.index === 0\n}\n\n/* No-op exec. */\nfunction execNoop() {\n  return null\n}\n\n/* Get a language by `name`. */\nfunction getLanguage(name) {\n  name = name.toLowerCase()\n\n  return languages[name] || languages[aliases[name]]\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","High","autoHighlight","value","options","settings","subset","languageNames","prefix","length","index","result","undefined","defaultPrefix","fault","secondBest","normalize","name","getLanguage","current","coreHighlight","language","relevance","registerAlias","alias","map","key","list","aliases","ignore","continuation","processLexeme","buffer","lexeme","modeBuffer","addSiblings","processBuffer","currentChildren","values","top","contains","test","beginRe","newMode","startNewMode","returnBegin","endMode","endOfMode","origin","returnEnd","excludeEnd","className","stack","pop","children","parent","addText","starts","illegalRe","mode","node","build","excludeBegin","push","Object","create","subLanguage","explicit","languages","subvalue","continuations","nodes","keywords","lastIndex","lexemesRe","keyword","exec","substring","keyInsensitive","toLowerCase","own","call","submatch","substr","siblings","sibling","type","T_TEXT","tail","contents","noPrefix","T_ELEMENT","tagName","T_SPAN","properties","endRe","endsParent","endsWithParent","match","compileLanguage","offset","terminators","count","error","message","indexOf","compileMode","flatten","pairs","split","space","pair","pipe","compiledKeywords","Number","compiled","beginKeywords","keys","forEach","langRe","lexemes","begin","join","end","terminatorEnd","source","illegal","concat","apply","c","variants","keyCachedVariants","inherit","filter","Boolean","execNoop","RegExp","re","expression","high","prototype","low","highlight","highlightAuto","registerLanguage","syntax","lang","hasOwnProperty"]
}
